<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit Price Growth Control</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            margin-bottom: 20px;
            color: #333;
            font-size: 24px;
        }

        .info {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 14px;
            color: #666;
        }

        .info strong {
            color: #333;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: 500px;
            margin: 20px 0;
        }

        canvas {
            cursor: crosshair;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            outline: none;
        }

        canvas:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
        }

        .tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.85);
            color: #333;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid rgba(0, 0, 0, 0.1);
            top: 10px;
            left: 10px;
            min-width: 200px;
            backdrop-filter: none;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip .year {
            font-weight: bold;
            margin-bottom: 6px;
            color: #007bff;
            font-size: 14px;
        }

        .tooltip .value {
            margin: 4px 0;
            color: #555;
        }

        .tooltip .year {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip .value {
            margin: 3px 0;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #545b62;
        }

        .auto-growth-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .auto-growth-controls label {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .auto-growth-controls input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            width: 80px;
            text-align: center;
        }

        .auto-growth-controls input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
        }

        .auto-growth-controls .percent-symbol {
            font-size: 14px;
            color: #666;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Unit Price Growth Control</h1>
        <div class="info">
            <strong>Базовая цена юнита:</strong> $<span id="basePriceDisplay">100,000</span><br>
            <strong>Диапазон:</strong> <span id="rangeInfo">от -20% до +200%</span> (автоматически расширяется)<br>
            <strong>Период:</strong> <span id="yearsDisplay">30</span> лет<br>
            <strong>Инструкция:</strong> Перетащите точки на графике вверх или вниз, чтобы изменить рост стоимости. Все точки справа от перемещенной точки поднимутся на ту же величину. Шаг изменения: 1%.
        </div>
        <div class="chart-container">
            <canvas id="chart" tabindex="0"></canvas>
            <div class="tooltip" id="tooltip"></div>
        </div>
        <div class="auto-growth-controls">
            <label for="basePriceInput">Базовая стоимость:</label>
            <input type="number" id="basePriceInput" value="100000" min="1" step="1000" style="width: 120px;">
            <span style="margin-right: 20px;">$</span>
            <label for="yearsInput">Количество лет:</label>
            <input type="number" id="yearsInput" value="30" min="5" max="50" step="1" style="width: 80px;">
            <span style="margin-right: 20px;">лет</span>
            <label for="completionYearInput">Дата сдачи юнита:</label>
            <input type="number" id="completionYearInput" value="2028" min="2026" max="2056" step="1" style="width: 100px;">
            <span style="margin-right: 20px;">год</span>
            <label for="growthPercent">Рост каждый год:</label>
            <input type="number" id="growthPercent" value="5" min="-100" max="500" step="1">
            <span class="percent-symbol">%</span>
            <button onclick="applyAutoGrowth()">Применить</button>
        </div>
        <div class="controls">
            <button onclick="resetChart()">Сбросить график к нулю</button>
            <button class="secondary" onclick="exportData()">Экспорт данных</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('chart');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        // Конфигурация
        let BASE_PRICE = 100000;
        let YEARS = 30; // Количество лет расчета
        const CURRENT_YEAR = 2026; // Текущий год (стартовая точка)
        let COMPLETION_YEAR = 2028; // Год сдачи юнита
        const DEFAULT_MIN_PERCENT = -20;
        const DEFAULT_MAX_PERCENT = 200;
        const BUFFER_PERCENT = 20; // Буфер сверху и снизу в процентах
        const PADDING = { top: 40, right: 40, bottom: 80, left: 80 };

        // Данные графика (проценты роста для каждого года)
        let growthData = new Array(YEARS).fill(0);
        
        // Динамический диапазон (вычисляется на основе данных)
        let MIN_PERCENT = DEFAULT_MIN_PERCENT;
        let MAX_PERCENT = DEFAULT_MAX_PERCENT;

        // Размеры canvas
        let width, height;
        let chartWidth, chartHeight;

        // Состояние для drag-and-drop
        let isDragging = false;
        let draggedPointIndex = -1;
        let dragStartY = 0;
        let dragStartPercent = 0;
        let originalValues = []; // Исходные значения всех точек в момент начала перетаскивания
        
        // Выбранная точка для клавиатурного управления
        let selectedPointIndex = 0; // По умолчанию первая точка

        function resizeCanvas() {
            const container = canvas.parentElement;
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            chartWidth = width - PADDING.left - PADDING.right;
            chartHeight = height - PADDING.top - PADDING.bottom;
            drawChart();
        }

        function percentToY(percent) {
            const range = MAX_PERCENT - MIN_PERCENT;
            const normalized = (percent - MIN_PERCENT) / range;
            return PADDING.top + chartHeight * (1 - normalized);
        }

        function yToPercent(y) {
            const normalized = (y - PADDING.top) / chartHeight;
            const percent = MIN_PERCENT + (1 - normalized) * (MAX_PERCENT - MIN_PERCENT);
            return Math.max(MIN_PERCENT, Math.min(MAX_PERCENT, percent));
        }

        function xToYear(x) {
            const normalized = (x - PADDING.left) / chartWidth;
            const year = Math.round(normalized * (YEARS - 1));
            return Math.max(0, Math.min(YEARS - 1, year));
        }

        function yearToX(year) {
            const normalized = year / (YEARS - 1);
            return PADDING.left + normalized * chartWidth;
        }

        function updateDynamicRange() {
            // Находим минимальное и максимальное значения в данных
            const minValue = Math.min(...growthData);
            const maxValue = Math.max(...growthData);
            
            // Вычисляем новый диапазон с буфером
            let newMin = Math.min(DEFAULT_MIN_PERCENT, minValue - BUFFER_PERCENT);
            let newMax = Math.max(DEFAULT_MAX_PERCENT, maxValue + BUFFER_PERCENT);
            
            // Округляем до целых процентов
            MIN_PERCENT = Math.floor(newMin);
            MAX_PERCENT = Math.ceil(newMax);
            
            // Обеспечиваем минимальный диапазон
            if (MAX_PERCENT - MIN_PERCENT < 50) {
                const center = (MIN_PERCENT + MAX_PERCENT) / 2;
                MIN_PERCENT = Math.floor(center - 25);
                MAX_PERCENT = Math.ceil(center + 25);
            }
            
            // Обновляем текст диапазона в интерфейсе
            const rangeInfo = document.getElementById('rangeInfo');
            if (rangeInfo) {
                rangeInfo.textContent = `от ${MIN_PERCENT}% до +${MAX_PERCENT}%`;
            }
        }

        function drawChart() {
            // Обновляем динамический диапазон на основе данных
            updateDynamicRange();
            
            // Очистка
            ctx.clearRect(0, 0, width, height);

            // Фон
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);

            // Сетка и оси
            drawAxes();
            
            // Линия графика
            drawLine();
            
            // Точки
            drawPoints();
            
            // Обновляем tooltip для выбранной точки
            updateSelectedTooltip();
        }

        function drawAxes() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Горизонтальные линии (проценты) - генерируем динамически
            const range = MAX_PERCENT - MIN_PERCENT;
            let step = 50; // Шаг по умолчанию
            
            // Адаптируем шаг в зависимости от диапазона
            if (range > 500) step = 100;
            else if (range > 200) step = 50;
            else if (range > 100) step = 25;
            else if (range > 50) step = 10;
            else step = 5;
            
            // Генерируем линии сетки
            const startPercent = Math.ceil(MIN_PERCENT / step) * step;
            const endPercent = Math.floor(MAX_PERCENT / step) * step;
            
            for (let percent = startPercent; percent <= endPercent; percent += step) {
                const y = percentToY(percent);
                ctx.beginPath();
                ctx.moveTo(PADDING.left, y);
                ctx.lineTo(width - PADDING.right, y);
                ctx.stroke();

                // Подпись
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(percent + '%', PADDING.left - 10, y + 4);
            }
            
            // Всегда показываем 0%, если он в диапазоне
            if (0 >= MIN_PERCENT && 0 <= MAX_PERCENT) {
                const y = percentToY(0);
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(PADDING.left, y);
                ctx.lineTo(width - PADDING.right, y);
                ctx.stroke();
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
            }

            // Вертикальные линии (годы)
            for (let i = 0; i < YEARS; i += 5) {
                const x = yearToX(i);
                ctx.beginPath();
                ctx.moveTo(x, PADDING.top);
                ctx.lineTo(x, height - PADDING.bottom);
                ctx.stroke();
            }
            
            // Первая строка: номера лет (1, 2, 3, 4, 5...)
            for (let i = 0; i < YEARS; i++) {
                const x = yearToX(i);
                ctx.fillStyle = '#666';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), x, height - PADDING.bottom + 15);
            }
            
            // Вторая строка: реальные годы (через каждые 5 лет) + дата сдачи
            const completionYearIndex = getYearIndex(COMPLETION_YEAR);
            
            // Показываем реальные годы через каждые 5 лет
            for (let i = 0; i < YEARS; i += 5) {
                const x = yearToX(i);
                const year = CURRENT_YEAR + i;
                ctx.fillStyle = '#666';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(year.toString(), x, height - PADDING.bottom + 30);
            }
            
            // Показываем дату сдачи красным цветом
            if (completionYearIndex >= 0 && completionYearIndex < YEARS) {
                const completionX = yearToX(completionYearIndex);
                
                // Красная вертикальная линия для года сдачи
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Пунктирная линия
                ctx.beginPath();
                ctx.moveTo(completionX, PADDING.top);
                ctx.lineTo(completionX, height - PADDING.bottom);
                ctx.stroke();
                ctx.setLineDash([]); // Сбрасываем пунктир
                
                // Подпись года сдачи красным цветом (если не совпадает с уже показанным годом)
                const completionYear = CURRENT_YEAR + completionYearIndex;
                const isAlreadyShown = (completionYearIndex % 5 === 0);
                if (!isAlreadyShown) {
                    ctx.fillStyle = '#dc3545';
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(COMPLETION_YEAR.toString(), completionX, height - PADDING.bottom + 30);
                } else {
                    // Если год сдачи совпадает с одним из показанных, перекрашиваем его в красный
                    ctx.fillStyle = '#dc3545';
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(COMPLETION_YEAR.toString(), completionX, height - PADDING.bottom + 30);
                }
            }

            // Ось Y (проценты)
            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Рост стоимости (%)', 0, 0);
            ctx.restore();

            // Ось X (годы)
            ctx.fillStyle = '#333';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Годы', width / 2, height - 10);
        }

        function drawLine() {
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let i = 0; i < YEARS; i++) {
                const x = yearToX(i);
                const y = percentToY(growthData[i]);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();
        }

        function getYearIndex(year) {
            return year - CURRENT_YEAR;
        }

        function drawPoints() {
            const completionYearIndex = getYearIndex(COMPLETION_YEAR);
            
            for (let i = 0; i < YEARS; i++) {
                const x = yearToX(i);
                const y = percentToY(growthData[i]);
                const isSelected = i === selectedPointIndex;
                const isCompletionYear = i === completionYearIndex;
                
                // Внешний круг для выделенной точки
                if (isSelected) {
                    ctx.fillStyle = '#ffc107';
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Круг для точки - красный для года сдачи
                if (isCompletionYear) {
                    ctx.fillStyle = '#dc3545';
                } else {
                    ctx.fillStyle = isSelected ? '#ff9800' : '#007bff';
                }
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Обводка
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Текст с процентом изменения относительно предыдущего года
                let changePercent;
                if (i === 0) {
                    // Для первого года - изменение от базового значения (0%)
                    changePercent = growthData[0];
                } else {
                    // Для остальных - изменение относительно предыдущего года
                    changePercent = growthData[i] - growthData[i - 1];
                }
                
                // Показываем только если есть изменение
                if (Math.abs(changePercent) > 0.1) {
                    const textY = y - 15; // Над точкой
                    const text = (changePercent > 0 ? '+' : '') + Math.round(changePercent) + '%';
                    
                    // Цвет: зеленый для положительных, красный для отрицательных
                    ctx.fillStyle = changePercent >= 0 ? '#28a745' : '#dc3545';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    
                    // Фон для лучшей читаемости
                    const textWidth = ctx.measureText(text).width;
                    const padding = 3;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(x - textWidth / 2 - padding, textY - 10, textWidth + padding * 2, 12);
                    
                    // Текст
                    ctx.fillStyle = changePercent >= 0 ? '#28a745' : '#dc3545';
                    ctx.fillText(text, x, textY);
                }
            }
        }

        function getPointAt(x, y) {
            const threshold = 15;
            for (let i = 0; i < YEARS; i++) {
                const px = yearToX(i);
                const py = percentToY(growthData[i]);
                const distance = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
                if (distance < threshold) {
                    return i;
                }
            }
            return -1;
        }

        function updateTooltip(x, y, yearIndex) {
            if (yearIndex === -1) {
                // Не скрываем tooltip если есть выбранная точка
                if (selectedPointIndex !== -1) {
                    updateSelectedTooltip();
                } else {
                    tooltip.classList.remove('visible');
                }
                return;
            }

            const percent = growthData[yearIndex];
            const currentPrice = BASE_PRICE * (1 + percent / 100);
            const year = CURRENT_YEAR + yearIndex;
            const isCompletionYear = year === COMPLETION_YEAR;

            tooltip.innerHTML = `
                <div class="year">${year} ${isCompletionYear ? '(сдача юнита)' : ''}</div>
                <div class="value">Рост: ${percent > 0 ? '+' : ''}${Math.round(percent)}%</div>
                <div class="value">Стоимость: $${currentPrice.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
            `;

            // Позиционируем всегда сверху слева
            tooltip.style.left = '10px';
            tooltip.style.top = '10px';
            tooltip.classList.add('visible');
        }

        function updateSelectedTooltip() {
            if (selectedPointIndex < 0 || selectedPointIndex >= YEARS) return;
            
            const percent = growthData[selectedPointIndex];
            const currentPrice = BASE_PRICE * (1 + percent / 100);
            const year = CURRENT_YEAR + selectedPointIndex;
            const isCompletionYear = year === COMPLETION_YEAR;

            tooltip.innerHTML = `
                <div class="year">${year} ${isCompletionYear ? '(сдача юнита)' : '(выбрано)'}</div>
                <div class="value">Рост: ${percent > 0 ? '+' : ''}${Math.round(percent)}%</div>
                <div class="value">Стоимость: $${currentPrice.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                <div style="margin-top: 8px; font-size: 11px; color: #888; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 6px;">↑↓ переместить | ←→ выбрать | Shift+↑↓ ±5%</div>
            `;

            // Позиционируем всегда сверху слева
            tooltip.style.left = '10px';
            tooltip.style.top = '10px';
            tooltip.classList.add('visible');
        }

        function handlePointDrag(yearIndex, deltaY) {
            const newPercent = yToPercent(dragStartY + deltaY);
            const deltaPercent = newPercent - dragStartPercent;
            // Округляем дельту до целых процентов
            const roundedDeltaPercent = Math.round(deltaPercent);
            
            // Обновляем текущую точку и все точки справа от неё на ту же дельту
            // Используем исходные значения, сохраненные в момент начала перетаскивания
            for (let i = yearIndex; i < YEARS; i++) {
                const originalValue = originalValues[i];
                const newValue = originalValue + roundedDeltaPercent;
                // Округляем итоговое значение до целых процентов и ограничиваем диапазоном
                growthData[i] = Math.max(MIN_PERCENT, Math.min(MAX_PERCENT, Math.round(newValue)));
            }
            
            drawChart();
        }

        // События мыши
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const pointIndex = getPointAt(x, y);
            if (pointIndex !== -1) {
                // Выбираем точку при клике
                selectedPointIndex = pointIndex;
                updateSelectedTooltip();
                drawChart();
                
                // Начинаем перетаскивание
                isDragging = true;
                draggedPointIndex = pointIndex;
                dragStartY = y;
                dragStartPercent = growthData[pointIndex];
                // Сохраняем исходные значения всех точек в момент начала перетаскивания
                originalValues = [...growthData];
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (isDragging) {
                const deltaY = y - dragStartY;
                handlePointDrag(draggedPointIndex, deltaY);
                updateTooltip(e.clientX - rect.left, e.clientY - rect.top, draggedPointIndex);
            } else {
                const pointIndex = getPointAt(x, y);
                if (pointIndex !== -1) {
                    canvas.style.cursor = 'grab';
                    updateTooltip(x, y, pointIndex);
                } else {
                    canvas.style.cursor = 'crosshair';
                    // Показываем tooltip выбранной точки если не наводим на другую
                    updateSelectedTooltip();
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                draggedPointIndex = -1;
                canvas.style.cursor = 'crosshair';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDragging) {
                isDragging = false;
                draggedPointIndex = -1;
                canvas.style.cursor = 'crosshair';
            }
            // Не скрываем tooltip выбранной точки
            updateSelectedTooltip();
        });

        // Обработчики клавиатуры
        canvas.addEventListener('keydown', (e) => {
            if (selectedPointIndex < 0 || selectedPointIndex >= YEARS) return;
            
            let handled = false;
            
            // Стрелки влево/вправо - переключение между точками
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                selectedPointIndex = Math.max(0, selectedPointIndex - 1);
                updateSelectedTooltip();
                drawChart();
                handled = true;
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                selectedPointIndex = Math.min(YEARS - 1, selectedPointIndex + 1);
                updateSelectedTooltip();
                drawChart();
                handled = true;
            }
            
            // Стрелки вверх/вниз - перемещение точки
            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                const delta = e.key === 'ArrowUp' ? 1 : -1;
                
                // Если зажат Shift, перемещаем на 5%
                const step = e.shiftKey ? 5 : 1;
                const deltaPercent = delta * step;
                
                // Сохраняем исходные значения
                originalValues = [...growthData];
                dragStartPercent = growthData[selectedPointIndex];
                
                // Применяем изменение
                for (let i = selectedPointIndex; i < YEARS; i++) {
                    const originalValue = originalValues[i];
                    growthData[i] = Math.max(MIN_PERCENT, Math.min(MAX_PERCENT, Math.round(originalValue + deltaPercent)));
                }
                
                updateSelectedTooltip();
                drawChart();
                handled = true;
            }
            
            if (handled) {
                canvas.focus(); // Сохраняем фокус на canvas
            }
        });

        // Убеждаемся, что canvas может получать фокус
        canvas.addEventListener('click', () => {
            canvas.focus();
        });

        function resetChart() {
            growthData = new Array(YEARS).fill(0);
            selectedPointIndex = 0;
            drawChart();
        }

        function applyAutoGrowth() {
            const input = document.getElementById('growthPercent');
            const growthPercent = parseFloat(input.value);
            
            if (isNaN(growthPercent)) {
                alert('Пожалуйста, введите корректное значение процента');
                return;
            }
            
            // Создаем равномерный рост на указанный процент каждый год
            // Каждый год добавляется указанный процент к предыдущему значению
            let cumulativeGrowth = 0;
            for (let i = 0; i < YEARS; i++) {
                cumulativeGrowth += growthPercent;
                growthData[i] = Math.round(cumulativeGrowth);
            }
            
            selectedPointIndex = 0;
            drawChart();
        }

        function exportData() {
            const data = {
                basePrice: BASE_PRICE,
                currentYear: CURRENT_YEAR,
                completionYear: COMPLETION_YEAR,
                years: YEARS,
                growthData: growthData.map((percent, index) => ({
                    year: CURRENT_YEAR + index,
                    yearIndex: index + 1,
                    growthPercent: percent,
                    price: BASE_PRICE * (1 + percent / 100)
                }))
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'unit_price_growth_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Обработчик изменения базовой стоимости
        document.getElementById('basePriceInput').addEventListener('input', (e) => {
            const newPrice = parseFloat(e.target.value);
            if (!isNaN(newPrice) && newPrice > 0) {
                BASE_PRICE = newPrice;
                updateBasePriceDisplay();
                updateSelectedTooltip();
                drawChart();
            }
        });

        // Обработчик изменения года сдачи
        document.getElementById('completionYearInput').addEventListener('input', (e) => {
            const newYear = parseInt(e.target.value);
            if (!isNaN(newYear) && newYear >= CURRENT_YEAR && newYear <= CURRENT_YEAR + YEARS - 1) {
                COMPLETION_YEAR = newYear;
                updateSelectedTooltip();
                drawChart();
            }
        });

        // Обработчик изменения количества лет
        document.getElementById('yearsInput').addEventListener('input', (e) => {
            const newYears = parseInt(e.target.value);
            if (!isNaN(newYears) && newYears >= 5 && newYears <= 50) {
                const oldYears = YEARS;
                YEARS = newYears;
                
                // Обновляем массив данных
                if (YEARS > oldYears) {
                    // Добавляем нули для новых лет
                    for (let i = oldYears; i < YEARS; i++) {
                        growthData.push(0);
                    }
                } else if (YEARS < oldYears) {
                    // Удаляем лишние годы
                    growthData = growthData.slice(0, YEARS);
                }
                
                // Обновляем максимальное значение для года сдачи
                const maxYearInput = document.getElementById('completionYearInput');
                maxYearInput.max = CURRENT_YEAR + YEARS - 1;
                
                // Обновляем отображение количества лет
                const yearsDisplay = document.getElementById('yearsDisplay');
                if (yearsDisplay) {
                    yearsDisplay.textContent = YEARS;
                }
                
                // Проверяем, что выбранная точка в пределах
                if (selectedPointIndex >= YEARS) {
                    selectedPointIndex = YEARS - 1;
                }
                
                // Проверяем, что год сдачи в пределах
                if (COMPLETION_YEAR > CURRENT_YEAR + YEARS - 1) {
                    COMPLETION_YEAR = CURRENT_YEAR + YEARS - 1;
                    document.getElementById('completionYearInput').value = COMPLETION_YEAR;
                }
                
                updateSelectedTooltip();
                drawChart();
            }
        });

        function updateBasePriceDisplay() {
            const display = document.getElementById('basePriceDisplay');
            if (display) {
                display.textContent = BASE_PRICE.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0});
            }
        }

        // Инициализация
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        updateBasePriceDisplay();
        
        // Устанавливаем максимальное значение для года сдачи
        document.getElementById('completionYearInput').max = CURRENT_YEAR + YEARS - 1;
        
        // Обновляем отображение количества лет
        const yearsDisplay = document.getElementById('yearsDisplay');
        if (yearsDisplay) {
            yearsDisplay.textContent = YEARS;
        }
        
        // Показываем tooltip выбранной точки при загрузке
        setTimeout(() => {
            updateSelectedTooltip();
            canvas.focus();
        }, 100);
    </script>
</body>
</html>